---
id: 20230510204447_7012983f4d224a11
date: "2023-05-10"
aliases:
- 锁相关的概念
- java 锁相关概念
- "#公平锁"
- "#非公平锁"
category:
- gist
gist:
  language:
  - programming/lock
  tags:
  - lock
  - 锁
  - java/锁
  - golang/锁
  - 并发
  - 并行
  - 多线程
  - 性能优化
tc:
- gist
---

## 独占性

- 独占锁(互斥锁): 只有获得锁后才可以进行之后的操作
- 读写锁(共享-互斥锁): 获得读锁(共享锁)之间不会互相影响, 获得写锁(独占锁)会阻塞所有其他所有线程

## 公平性

- 公平锁: 每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁
- 非公平锁：每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁

java 的 synchronize 是非公平锁, ReentrantLock 可以根据参数进行设定.

高度竞争和锁持续时间较小情况下, 非公平锁有更好的团吐量. 在锁持续时间较长情况下公平锁会更好.

## 重入

- 可重入: 线程 A 可以重复获取已经获取的锁, 不会被阻塞就说明, 这个锁是可重入的.
- 不可重入入: 于可重入相反, 不允许重复获得.

可重入和不可重入的重要的区别可以理解成, "锁的粒度不同", 一个是锁在线程上的, 一个锁调用上的.
POSIX 模型中的锁是不可重入的, golang 的 sync.Mutex 是不可冲入的, Java 的 synchronize 是可重入的.

一个简单例子, 在 java 中, 这个递归调用不会被阻塞可以正常运行
```java
public int synchronize sum(int i) {
    if (i<=0) {
        return 0
    }
    return i+loop(i-1)
}
```

在 golang 中, 这个递归调用就会阻塞, 报错显示存在死锁的情况
```golang
lock = new(sync.Mutex)

func sum(i int) int {
    lock.Lock()
    defer lock.Unlock()
    if i <= 0 {
        return 0
    }
    return i + loop(i-1)
}
```

## jvm 中的一些锁优化技术

### 自旋锁

前提假设, 锁定状态只会持续**很短**的一段时间, 并且有多个 CPU 核心(多个线程是[[20230223173106|并行的]]).

线程 A 已经获取锁, 线程 B 在请求锁的时候不会选择挂起, 而是循环等待, 看看 A 在之后会不会释放锁.
主要是防止线程挂起和恢复导致的性能损耗

### 锁消除

基于逃逸分析, 判断一块数据是否存在数据竞争, 就不进行加锁操作

### 锁粗化

在锁使用中的一个原则是, 减小锁的粒度. 锁粗化就是在一些场景下违法这个原则, 扩大锁的范围.

比如在循环中重复获取锁和释放锁, 可以调整成循环外的使用.

### 轻量级锁/重量级锁/偏向锁

为了进一步消除在没有数据竞争情况下同步原语的性能, 在 1.6 中引入了偏向锁.

偏向锁: 在第一个线程获得锁后, 如果接下来的执行过程中, 该锁没有把其他线程获取, 则持有偏向锁的线程永远不需要在进行铜鼓

轻量级锁假设, "对于绝对部分的锁, 在整个同步周期内都是不存在竞争的"

轻量级锁: 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁: 基于互斥量实现的锁(也是1.6之前同步原语的实现机制)**

synchronized 是通过对象内部的监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于**底层的操作系统的互斥锁（Mutex Lock）来实现的**。(也就是需要从用户态两者之间进行切换内核态)
